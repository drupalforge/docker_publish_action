name: 'Drupal Forge build platform image'
description: 'Builds and pushes a platform image tagged by branch name to Docker Hub for a Drupal Forge template.'
author: 'Drupal Forge'
branding:
  icon: 'package'
  color: 'blue'
inputs:
  dockerhub_username:
    description: 'Docker Hub username'
    required: true
  dockerhub_token:
    description: 'Docker Hub token'
    required: true
  dp_ai_virtual_key:
    description: 'DevPanel AI Virtual Key'
    required: false
  image_repo:
    description: 'Docker Hub image repository'
    required: false
  files_to_hash:
    description: 'List of files to check for changes (space or newline separated). Defaults to composer.lock if not provided.'
    required: false
  cached_hash:
    description: 'Previously cached files hash for comparison.'
    required: false
  build_platform:
    description: 'Target platform for the build. Defaults to linux/amd64.'
    required: false
runs:
  using: "composite"
  steps:
    - name: Check out code
      uses: actions/checkout@v4
      with:
        path: app

    - name: Check out Dockerfile
      uses: actions/checkout@v4
      with:
        repository: drupalforge/docker_publish_action
        ref: develop
        path: docker_publish_action

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ inputs.dockerhub_username }}
        password: ${{ inputs.dockerhub_token }}

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3

    - name: Try Docker Buildx Cloud builder
      if: inputs.build_platform && inputs.build_platform != 'linux/amd64'
      id: buildx_cloud
      continue-on-error: true
      uses: docker/setup-buildx-action@v3
      with:
        driver: cloud
        endpoint: "${{ inputs.dockerhub_username }}/github"

    - name: Fall back to docker-container builder if cloud did not succeed
      if: steps.buildx_cloud.outcome != 'success'
      uses: docker/setup-buildx-action@v3

    - name: Set IMAGE_REPO variable
      run: |
        echo "IMAGE_REPO=${{ inputs.image_repo || github.repository }}" >> $GITHUB_ENV
      shell: bash

    - name: Build image (no push, load to local Docker)
      id: build_image
      uses: docker/build-push-action@v6
      with:
        context: ./app
        file: ./docker_publish_action/Dockerfile
        platforms: ${{ inputs.build_platform || 'linux/amd64' }}
        build-args: |
          APP_ROOT=/var/www/html
          APACHE_RUN_USER=www
          APACHE_RUN_GROUP=www
        push: false
        load: true

    - name: Run init.sh in container with MySQL
      id: post_build_init
      run: |
        WEBSERVER=$(docker run -d --network ${NETWORK:-bridge} \
          -e DP_APP_ID=$IMAGE_REPO \
          -e DP_AI_VIRTUAL_KEY=${{ inputs.dp_ai_virtual_key || null }} \
          -e APP_ROOT="/var/www/html" \
          -e WEB_ROOT="/var/www/html/web" \
          -e APACHE_RUN_USER="www" \
          -e APACHE_RUN_GROUP="www" \
          -e CODES_ENABLE="no" \
          -e DB_HOST="mysql" \
          -e DB_PORT="3306" \
          -e DB_ROOT_PASSWORD="root" \
          -e DB_NAME="drupaldb" \
          -e DB_USER="user" \
          -e DB_PASSWORD="password" \
          -e DB_DRIVER="mysql" \
          ${{ steps.build_image.outputs.imageid }})
        echo "WEBSERVER=$WEBSERVER" >> $GITHUB_ENV
        echo "INSTALL DRUPAL"
        docker exec $WEBSERVER sh -c '$APP_ROOT/.devpanel/init.sh'
      shell: bash

    - name: Hash current files
      id: hash_files
      env:
        FILES_TO_HASH: ${{ inputs.files_to_hash || 'composer.lock' }}
      run: |
        echo "HASH FILES"
        APP_ROOT=$(docker exec $WEBSERVER bash -c 'echo $APP_ROOT')
        HASH=""
        if [ -n "$FILES_TO_HASH" ]; then
          echo "Hashing $FILES_TO_HASH in $APP_ROOT to check for changes."
          EXISTING_FILES=""
          # Use eval and set to handle quoted filenames with spaces
          eval set -- $FILES_TO_HASH
          for f; do
            # Always check relative to $APP_ROOT
            if docker exec $WEBSERVER bash -c "cd \$APP_ROOT && [ -f \"$f\" ]"; then
              EXISTING_FILES="${EXISTING_FILES}${f}\n"
            fi
          done
          if [ -n "$EXISTING_FILES" ]; then
            EXISTING_FILES=$(printf "%b" "$EXISTING_FILES" | sort)
            while IFS= read -r f; do
              [ -z "$f" ] && continue
              FILE_HASH=$(docker exec $WEBSERVER bash -c "cd \$APP_ROOT && sha256sum \"$f\" | awk '{print \$1}'")
              if [ -z "$HASH" ]; then
                HASH="$FILE_HASH"
              else
                HASH=$(printf "%s%s" "$HASH" "$FILE_HASH" | sha256sum | awk '{print $1}')
              fi
            done <<< "$EXISTING_FILES"
          fi
        fi
        echo "hash=$HASH" >> $GITHUB_OUTPUT
      shell: bash

    - name: Compare current and previouse file hashes
      if: github.event_name != 'push' && steps.hash_files.outputs.hash != ''
      id: compare_hash
      env:
        CACHED_HASH: ${{ inputs.cached_hash }}
        HASH: ${{ steps.hash_files.outputs.hash }}
      run: |
        echo "CHECK FOR CHANGES"
        if [ -n "${CACHED_HASH+x}" ] && [ "$CACHED_HASH" == "$HASH" ]; then
          echo "Hash unchanged, skipping rest of the action."
          echo "skip=true" >> $GITHUB_OUTPUT
        fi
      shell: bash

    - name: Save database and files dumps
      if: steps.compare_hash.outputs.skip != 'true'
      run: |
        echo "DUMPS DATABASE + STATIC FILE"
        docker exec $WEBSERVER bash -c '$APP_ROOT/.devpanel/create_quickstart.sh'
        docker exec $WEBSERVER bash -c 'rm $APP_ROOT/.devpanel/dumps/files.tgz'
      shell: bash

    - name: Commit and push the container state to Docker Hub
      if: steps.compare_hash.outputs.skip != 'true'
      id: push_image
      run: |
        docker commit $WEBSERVER $IMAGE_REPO:${{ github.ref_name }}
        docker push $IMAGE_REPO:${{ github.ref_name }}
        IMAGE=$(docker inspect --format='{{index .RepoDigests 0}}' $IMAGE_REPO:${{ github.ref_name }})
        echo "image=$IMAGE" >> $GITHUB_OUTPUT
      shell: bash
outputs:
  hash:
    description: 'Files hash'
    value: ${{ steps.hash_files.outputs.hash }}
  skip:
    description: 'Skip manifest generation'
    value: ${{ steps.compare_hash.outputs.skip }}
  image:
    description: 'Image pushed for this platform'
    value: ${{ steps.push_image.outputs.image }}
